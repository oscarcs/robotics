#pragma config(Sensor, S1,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S2,     comp,           sensorI2CHiTechnicCompass)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Oscar, Jed, Will, Alex
 * Robotics Team 2015
 * 'The worker's party'
 */

 //SENSOR SETUP NOTES
 //1 is IR sensor
 //2 is compass sensor
 //A is right
 //C is left

#include "drivers/hitechnic-irseeker-v2.h"

//global variables
//don't set these too high! the update can't keep up!
int fast = 50;
int slow = 10;
int lastdirection = 0;
int targetDirection = 0;

//helper functions
int max(int x, int y)
{
	if (x > y) { return x; }
	else
	{ return y; }
}

int min(int x, int y)
{
	if (x < y) { return x; }
	else { return y; }
}

int dirDifference(int current, int target)
{
	int cur = (current - target) % 360;
	if (cur > 180)
	{
		cur = 360 - cur;
		cur = -cur;
	}
	return cur;
}

void turnLeft(int num_dist)
{
	motor[motorA] = fast;
	motor[motorC] =-slow;
	lastdirection = 1;
}

void turnRight(int num_dist)
{
	motor[motorA] =-slow;
	motor[motorC] = fast;
	lastdirection = 9;
}

void forward(int pwr)
{
	motor[motorA] = pwr;
	motor[motorC] = pwr;
}

void flick(bool left, bool right)
{
	int leftPwr = fast;
	int rightPwr = fast;

	if (left)
	{
		leftPwr = slow;
	}

	if (right)
	{
		rightPwr = slow;
	}

	if(left && right)
	{
		leftPwr = fast;
		rightPwr = fast;
	}

	motor[motorA] = leftPwr;
	motor[motorC] = rightPwr;
}

void kickoff()
{
	motor[motorA] = fast;
	motor[motorC] = fast;
	wait1Msec(750);
	motor[motorA] = -fast;
	motor[motorC] = -fast;
	wait1Msec(500);
}

void turnToDirection(int current, int target)
{
	int cur = dirDifference(current, target);
	if(cur > 0)
	{
		flick(false, true);
	}
	else if (cur == 0)
	{
		flick(true, true);
	}
	else if (cur < 0)
	{
		flick(true, false);
	}
}

//always put this task last
task main()
{
	motor[motorA] = 0;
	motor[motorC] = 0;

	//set up sensor variables
	int _dirEnh, _strEnh;

	//we need our AC sensing to be at 1200Hz for w/e reason
  tHTIRS2DSPMode _mode = DSP_1200;

  //setup loop
  while (true)
	{
		// set the DSP to the new mode
		if (HTIRS2setDSPMode(HTIRS2, _mode))
		{
			break; // Sensor initialized
		}
		nxtDisplayCenteredTextLine(6, "Connect Sensor");
    nxtDisplayCenteredTextLine(7, "to Port S1!");
	} //setup

	//set up target
	targetDirection = SensorValue[S2];

	char str_targetDirection[15];
	sprintf(str_targetDirection, "%d", targetDirection);
	nxtDisplayCenteredTextLine(0, str_targetDirection);

	bFloatDuringInactiveMotorPWM = true;
	kickoff();

	//main loop
	while (true)
	{
		// Read the 'enhanced' direction and strength, which combines AC and DC readings for accuracy
		if (!HTIRS2readEnhanced(HTIRS2, _dirEnh, _strEnh))
		{
    	nxtDisplayCenteredTextLine(5, "I2C READ ERROR");
			wait1Msec(2500);
    	break; // I2C read error occurred
  	}

  	int comp = SensorValue[S2];
  	int dist = 310 - _strEnh;

    //print values to screen.
  	char str_dirEnh[15], str_strEnh[15], str_comp[15], str_dist[15];

  	//setup variables so we can show them on the screen
    sprintf(str_dirEnh, "%d", _dirEnh);
		sprintf(str_strEnh, "%d", _strEnh);
		sprintf(str_comp, "%d", comp);
		sprintf(str_dist, "%d", dist);
		//show the variables
    nxtDisplayCenteredTextLine(3, str_dirEnh);
    nxtDisplayCenteredTextLine(4, str_strEnh);
    nxtDisplayCenteredTextLine(5, str_comp);
    nxtDisplayCenteredTextLine(6, str_dist);

    int num_dist = abs(5 - _dirEnh);
    num_dist = (4 - num_dist) * 10;

		if(dist > 15)
		{
			//right
			if (_dirEnh > 5)
			{
				turnRight(num_dist);
			}
			//straight
			else if (_dirEnh == 5)
			{
				forward(fast);
			}
			//left
			else if (_dirEnh < 5)
			{
				turnLeft(num_dist);
			}
		}
		/*
		else if (abs(dirDifference(comp, targetDirection)) > 10)
		{
    	turnToDirection(comp, targetDirection);
  	}
  	*/

  	//if the ball is close and we are heading towards the goal
  	else if(abs(dirDifference(comp, targetDirection)) < 90) //invert
  	{
  		//right
			if (_dirEnh > 6)
			{
				turnLeft(num_dist);
			}
			//left
			else if (_dirEnh < 4)
			{
				turnRight(num_dist);
			}
			//straight
			else
			{
				forward(fast);
			}
		}

	} //main while loop
}
